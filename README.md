# Optimization of Smart City Task Scheduling  
**Assignment 4 – Implementation of SCC, Topological Ordering, and Shortest/Longest Paths in DAGs**


---

## 1. Abstract

This project applies advanced graph algorithms to optimize the scheduling of smart-city and smart-campus service tasks such as street cleaning, infrastructure maintenance, and sensor analytics.

The problem is modeled as a **Directed Weighted Graph (DWG)** where:  
- **Vertices** represent tasks or city service operations  
- **Edges** represent dependencies between tasks  
- **Edge weights** represent execution or delay cost  

The system integrates three major algorithms:
1. **Strongly Connected Components (Tarjan’s algorithm)**  
2. **Topological Sorting (Kahn’s algorithm)**  
3. **Shortest and Longest Paths in DAGs (Dynamic Programming)**  

---

## 2. Problem Definition

The main goal is to optimize task dependencies in a directed network by:
- Detecting cyclic dependencies and compressing them into single components (SCCs).  
- Ordering tasks in a valid sequence using topological sorting.  
- Computing optimal (shortest) and critical (longest) paths to support efficient planning.  

---

## 3. Methodology

### 3.1 Strongly Connected Components (Tarjan’s Algorithm)
- Identifies groups of tasks forming cycles.  
- Each SCC is treated as a single node in the condensation DAG.  
- Time complexity: **O(V + E)**.

### 3.2 Condensation DAG and Topological Sorting
- The condensation graph is **acyclic**, enabling valid task ordering.  
- Kahn’s algorithm is used to compute a **topological order**.  
- Complexity: **O(V + E)**.

### 3.3 Shortest and Longest Paths in DAG
- Shortest paths use edge weights to find minimal completion time.  
- Longest paths identify the **critical chain** of dependent tasks.  
- Implemented using **dynamic programming over the topological order**.  
- Complexity: **O(V + E)**.

---

## 4. Data Format

### 4.1 Input (JSON Graphs)
Each dataset is stored in `/data/` as a JSON file:

```json
{
  "directed": true,
  "n": 10,
  "source": 0,
  "edges": [
    { "u": 0, "v": 1, "w": 3.0 },
    { "u": 1, "v": 2, "w": 2.0 }
  ]
}
n — number of nodes (tasks)

edges — directed dependencies with weights (execution costs)

source — starting task for path algorithms

4.2 Dataset Categories
Category	Nodes	Description	Variants
Small	6–10	Simple cycles or pure DAGs	3
Medium	10–20	Mixed structures with 2–4 SCCs	3
Large	20–50	Dense graphs with multiple SCCs	3

Total: 9 datasets, generated by DataGenerator.java.

5. Implementation Details
Packages:

css
Copy code
graph.scc     - TarjanSCC, CondensationBuilder  
graph.topo    → TopoKahn  
graph.dagsp   → DagShortestPath, DagLongestPath  
graph.common  → Graph, Metrics  
app           → Main, DataGenerator
Metrics Tracked:

DFS visits and edges explored (SCC)

Queue operations (Kahn’s algorithm)

Relaxations and runtime (DAG shortest/longest paths)

All execution times are measured using System.nanoTime().

6. Experimental Results
Table 1. Dataset Summary and Performance

```test
Dataset	Nodes	Edges	SCCs	Type	Critical Path	Time (ms)
small_1	9	22	3	Cyclic	70.0	0.05
small_2	10	24	2	Mixed	63.0	0.05
small_3	10	29	1	Fully cyclic	102.0	0.02
medium_1	15	45	2	Mixed	126.0	0.14
medium_2	11	26	4	Mixed	57.0	0.04
medium_3	14	35	5	Mixed	65.0	0.06
large_1	49	144	7	Dense	382.0	0.13
large_2	23	67	6	Mixed	156.0	0.05
large_3	36	106	10	Dense	256.0	0.11

```

Observation:

SCC detection successfully reduced cyclic subgraphs into single DAG nodes.

Topological sorting provided valid execution order across all datasets.

Longest paths matched the total internal weights of the largest SCCs.

Execution time remained in the millisecond range, even for 50-node graphs.

7. Discussion
Criterion	SCC + Condensation	Topological Sort	DAG Shortest/Longest
Purpose	Detect & compress cycles	Order independent components	Optimize execution cost
Time complexity	O(V + E)	O(V + E)	O(V + E)
Best suited for	Cyclic dependency detection	Scheduling	Task time optimization
Observations	Cycles appear mostly in medium/large graphs	Produces consistent order	Longest path = critical chain

Analysis:

The combination of SCC and topological sorting forms a robust workflow scheduler.

DAG-based dynamic programming ensures efficient path computation.

Internal weights (sum of intra-SCC edges) correctly represent execution loads.

8. Conclusion
This project demonstrates a complete pipeline for dependency optimization and scheduling using graph algorithms.
All components (SCC detection, topological order, and path computation) were correctly implemented, tested, and analyzed across 9 datasets.

Author: Symbat Nogaibay
Course: Design and Analysis of Algorithms
