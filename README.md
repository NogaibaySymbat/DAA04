# Optimization of Smart City Task Scheduling

**Assignment 4 – Implementation of SCC, Topological Ordering, and Shortest/Longest Paths in DAGs**

## 1. Abstract

This project applies advanced graph algorithms to optimize the scheduling of smart-city and smart-campus service tasks such as street cleaning, infrastructure maintenance, and sensor analytics.

The problem is modeled as a Directed Weighted Graph (DWG) where:

Vertices represent tasks or city service operations

Edges represent dependencies between tasks

Edge weights represent execution or delay cost

The system integrates three major algorithms:

Strongly Connected Components (Tarjan’s algorithm)

Topological Sorting (Kahn’s algorithm)

Shortest and Longest Paths in DAGs (Dynamic Programming)

---------

## 2. Problem Definition

The main goal is to optimize task dependencies in a directed network by:

Detecting cyclic dependencies and compressing them into single components (SCCs).

Ordering tasks in a valid sequence using topological sorting.

Computing optimal (shortest) and critical (longest) paths to support efficient planning.

________


## 3. Methodology
3.1 Strongly Connected Components (Tarjan’s Algorithm)

Identifies groups of tasks forming cycles.

Each SCC is treated as a single node in the condensation DAG.

Time complexity: O(V + E).

3.2 Condensation DAG and Topological Sorting

The condensation graph is acyclic, enabling valid task ordering.

Kahn’s algorithm is used to compute a topological order.

Complexity: O(V + E).

3.3 Shortest and Longest Paths in DAG

Shortest paths use edge weights to find minimal completion time.

Longest paths identify the critical chain of dependent tasks.

Implemented using dynamic programming over the topological order.

Complexity: O(V + E).

---------------

## 4. Data Format
4.1 Input (JSON Graphs)

All datasets are stored in `src/main/resources/data/`.  
Each JSON file represents a **directed weighted graph** used for SCC detection, topological sorting, and shortest/longest path computation.  
This format applies to all 9 datasets (`small_1.json` … `small_3.json`, `medium_1.json` … `medium_3.json`, `large_1.json` … `large_3.json`) and the general reference file `tasks.json`.

Example — `tasks.json`:
```json
{
  "directed": true,
  "n": 8,
  "edges": [
    {"u": 0, "v": 1, "w": 3},
    {"u": 1, "v": 2, "w": 2},
    {"u": 2, "v": 3, "w": 4},
    {"u": 3, "v": 1, "w": 1},
    {"u": 4, "v": 5, "w": 2},
    {"u": 5, "v": 6, "w": 5},
    {"u": 6, "v": 7, "w": 1}
  ],
  "source": 4,
  "weight_model": "edge"
}

**Fields:**
- `directed` — whether the graph is directed (`true`)  
- `n` — number of vertices (tasks)  
- `edges` — list of directed edges with weights  
- `source` — starting vertex for shortest/longest path computation  
- `weight_model` — `"edge"` or `"node"`, defines how weights are applied

4.2 Dataset Categories
| **Category** | **Nodes** | **Description**                 | **Variants** |
| ------------ | --------- | ------------------------------- | ------------ |
| Small        | 6–10      | Simple cycles or pure DAGs      | 3            |
| Medium       | 10–20     | Mixed structures with 2–4 SCCs  | 3            |
| Large        | 20–50     | Dense graphs with multiple SCCs | 3            |


Total: 9 datasets, generated by DataGenerator.java.

----------

## 5. Implementation Details

### Packages

| **Package**    | **Description**                 |
| --------------- | ------------------------------- |
| `graph.scc`    | TarjanSCC, CondensationBuilder  |
| `graph.topo`   | TopoKahn                        |
| `graph.dagsp`  | DagShortestPath, DagLongestPath |
| `graph.common` | Graph, Metrics                  |
| `app`          | Main, DataGenerator             |

### Metrics Tracked
- **DFS visits** and **edges explored** (for SCC detection)  
- **Queue operations** (for Kahn’s topological algorithm)  
- **Relaxations** and **runtime** (for DAG shortest/longest paths)  
- All execution times are measured using `System.nanoTime()`  


### 5.1 Project Structure
DAA4/
│
├── .idea/ 
│
├── data/
│
├── src/
│ ├── main/
│ │ ├── java/
│ │ │ ├── app/
│ │ │ │ ├── Main.java
│ │ │ │ └── DataGenerator.java
│ │ │ ├── graph/
│ │ │ │ ├── common/
│ │ │ │ │ ├── Graph.java
│ │ │ │ │ └── Metrics.java
│ │ │ │ ├── dagsp/
│ │ │ │ │ ├── DagShortestPath.java
│ │ │ │ │ └── DagLongestPath.java
│ │ │ │ ├── scc/
│ │ │ │ │ ├── TarjanSCC.java
│ │ │ │ │ └── CondensationBuilder.java
│ │ │ │ └── topo/
│ │ │ │ └── TopoKahn.java
│ │ │
│ │ └── resources/
│ │ └── data/ 
│ │ ├── small_1.json
│ │ ├── small_2.json
│ │ ├── small_3.json
│ │ ├── medium_1.json
│ │ ├── medium_2.json
│ │ ├── medium_3.json
│ │ ├── large_1.json
│ │ ├── large_2.json
│ │ ├── large_3.json
│ │ └── tasks.json
│ │
│ └── test/
│ └── java/
│ └── graph/
│ ├── dagsp/
│ │ ├── DagShortestPathTest.java
│ │ └── DagLongestPathTest.java
│ ├── scc/
│ │ ├── TarjanSCTest.java
│ │ └── CondensationBuilderTest.java
│ └── topo/
│ └── TopoKahnTest.java
│
├── pom.xml # Maven build configuration
├── README.md # Project documentation
└── target/ # Auto-generated compiled classes and reports

### 6. Experimental Results

#### Table 1. Dataset Summary and Performance

| **Dataset** | **Nodes** | **Edges** | **SCCs** | **Type**     | **Critical Path** | **Time (ms)** |
|-------------|-----------|-----------|-----------|--------------|-------------------|---------------|
| small_1     | 9         | 22        | 3         | Cyclic       | 70.0              | 0.05          |
| small_2     | 10        | 24        | 2         | Mixed        | 63.0              | 0.05          |
| small_3     | 10        | 29        | 1         | Fully cyclic | 102.0             | 0.02          |
| medium_1    | 15        | 45        | 2         | Mixed        | 126.0             | 0.14          |
| medium_2    | 11        | 26        | 4         | Mixed        | 57.0              | 0.04          |
| medium_3    | 14        | 35        | 5         | Mixed        | 65.0              | 0.06          |
| large_1     | 49        | 144       | 7         | Dense        | 382.0             | 0.13          |
| large_2     | 23        | 67        | 6         | Mixed        | 156.0             | 0.05          |
| large_3     | 36        | 106       | 10        | Dense        | 256.0             | 0.11          |

### Observations

- SCC detection successfully reduced cyclic subgraphs into single DAG nodes.  
- Topological sorting provided valid execution order across all datasets.  
- Longest paths matched the total internal weights of the largest SCCs.  
- Execution time remained in the millisecond range, even for 50-node graphs.


---------


### 7. Discussion

| **Criterion**       | **SCC + Condensation**                      | **Topological Sort**         | **DAG Shortest/Longest**      |
| -------------------- | ------------------------------------------- | ---------------------------- | ----------------------------- |
| **Purpose**          | Detect & compress cycles                    | Order independent components | Optimize execution cost       |
| **Time complexity**  | O(V + E)                                    | O(V + E)                     | O(V + E)                      |
| **Best suited for**  | Cyclic dependency detection                 | Scheduling                   | Task time optimization        |
| **Observations**     | Cycles appear mostly in medium/large graphs | Produces consistent order    | Longest path = critical chain |

### Analysis

- The combination of **SCC** and **Topological Sorting** forms a robust workflow scheduler.  
- **DAG-based dynamic programming** ensures efficient path computation.  
- Internal weights (sum of intra-SCC edges) correctly represent execution loads.

---------  

## 8. Conclusion

This project demonstrates a complete pipeline for dependency optimization and scheduling using graph algorithms.
All components — SCC detection, topological order, and path computation — were correctly implemented, tested, and analyzed across 9 datasets.

Author: Symbat Nogaibay
Course: Design and Analysis of Algorithms
